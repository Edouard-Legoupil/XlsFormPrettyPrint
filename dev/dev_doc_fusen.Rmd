---
title: "Dev Doc XlsFormPrettyPrint"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data examples to demo the package

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->

The included demo [xlsform](https://github.com/Edouard-Legoupil/XlsFormPrettyPrint/blob/master/inst/demo.xlsx?raw=true) comes from [https://github.com/pmaengineering/ppp](https://github.com/pmaengineering/ppp)

```{r development-2}
# Run all this chunk in the console directly
# Create "inst/" directory
#dir.create(here::here("inst"))

# Example dataset
# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
xlsformpath <- system.file("demo.xlsx", package = "XlsFormPrettyPrint") 
 
```



# tabulate_form

```{r function-tabulate_form}
#' @title Combine the xlsform in single table for pretty printing
#'
#' @param xlsformpath path to the file with xlsform
#' @param label_language Language to be used in case you have more than one. If not specified, the 'default_language' in the 'settings' worksheet is used. If that is not specified and more than one language is in the XlsForm, the language that comes first within column order will be used.
#' 
#' @return a single data frame
#' @export
#' 
tabulate_form <- function(xlsformpath,
                          label_language = NULL) {

  
  # Additional Test
  # xlsformpath <- "inst/RMS_CAPI_v2_en_es_fr.xlsx"
  # label_language <- "Español (es)"
  # label_language <- "Français (fr)"
  # label_language <- "English (en)" 
  
  survey <- readxl::read_excel(xlsformpath, sheet = "survey")
  
  choices <- readxl::read_excel(xlsformpath, sheet = "choices") 
  
  settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
  
 
  
  ## Check if a default language is set up in the settings - and add the correct separator
  # for test settings$default_language <- NULL
  label_language <- ifelse( is.null(label_language),
                                      ifelse( is.null(settings$default_language), 
                                             label_language, 
                                             paste0("::",settings$default_language)),
                                     paste0("::",label_language))
  #label_language 
  
  modalities <- choices |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(labelmod = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language))  ,
                    namemod = name) 
    ## Calculate number modalities per list_name - if more than 8 - then we assume that
    ## those modalities will not be read by the enumerator and not be accounted for the interview duration estimation
    
  
  
  variables <-  survey |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)),
                    hint =  ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("hint")), paste0("hint",label_language)) ,
                    constraint_message =  dplyr::first(tidyselect::starts_with("constraint_message"))
                   # constraint_message = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("constraint_message")), paste0("constraint_message",label_language))
                    
                    ) |>
      
      
      # Clean the begin and end in case the _ would be missing...
      dplyr::mutate(type = dplyr::recode(type, 
                                          "begin group" = "begin_group" ,
                                          "end group"   ="end_group",
                                         "begin repeat" = "begin_repeat" ,
                                         "end repeat"   ="end_repeat")) |>
      
      ## spearate the type
      tidyr::separate(type, 
                          into = c("type", "list_name"), 
                          sep = " ",
                          fill = "right")   |>
      
      # dplyr::mutate(name_type = glue::glue('{name} \n *(type: {type})')) |>
      # dplyr::mutate(label_hint = glue::glue('{label} \n *(hint: {hint})')) |>
      dplyr::mutate(name_type = paste0(name, "\n *(type: ",type, ")")) |>
      dplyr::mutate(label_hint = paste0( 
                                  ifelse(is.na(label), "no label", label),
                                  ifelse(is.na(hint), "", 
                                                 paste0("\n *(hint: ", hint, ")") 
                                                 ) )) |>
    
    
    ## Make the relevant expression more legible
      ## Case relevant if not null...
      dplyr::mutate(relevant = stringr::str_replace_all( relevant,
                                                         pattern = "''",
                                                         replacement = "NULL")) |>
      dplyr::mutate(relevant = stringr::str_replace_all( relevant,
                                                         pattern = "!=",
                                                         replacement = " is not ")) |>
      dplyr::mutate(relevant = ifelse(is.na(relevant), 
                                       relevant, 
                                       paste0(name, " is relevant if ", stringr::str_replace_all( relevant,
                                                        # pattern = c( "(", "\\$", "{", "}", ")" ),
                                                        pattern = "[^[:alnum:][:blank:]+?><=_&/\\-]",
                                                         replacement = "")) )) |>
    
    ## Make the constraint expression more legible
     # dplyr::mutate(instruct = glue::glue('{relevant} \n *(constraint: {constraint_message})')) |>
      dplyr::mutate(instruct = paste0( 
                                  ifelse(is.na(relevant), "", relevant),
                                  ifelse(is.na(constraint_message), "", 
                                                 paste0("\n Constraint on ", name,": ", constraint_message, ")") 
                                                 ) )) |>
      
    ## Need to add more cleaning in case...
      dplyr::filter(!(is.na(type))) |>
      dplyr::filter(type != "calculate") |>
    
    ## Now merge with modalities
      dplyr::left_join(modalities, by = c("list_name")) |>
      dplyr::select(name_type ,label_hint, labelmod, namemod,  instruct) |>
      dplyr::distinct()
    
    return(variables)
    
}
 

```

```{r examples-tabulate_form}
# tabulate_form()

prettyform <- tabulate_form( xlsformpath = system.file("demo.xlsx", package = "XlsFormPrettyPrint") )

knitr::kable(utils::head(prettyform, 10))

```

```{r tests-tabulate_form}
# test_that("skeleton works", {
# 
# })
```

# interview_duration

```{r function-interview_duration}
#' @title Prepare a summary estimation of the interview duration. 
#' 
#' @description When designing a questionnaire, it is key to keep the interview duration under control. Typically less than 20 minutes for a phone interview and less than 40 minutes for a face to face interview. 
#' 
#' The function is designed to provide a rough estimate (aka a guesstimate...) of the interview duration in order to assess this element of questionnaire design quality. If the questionnaire takes too long, then one needs to trim it or split it into multiple ones...
#' 
#' The estimations provided in that function are based on a series of assumptions and accounts for the following elements:
#'   * the time needed to read the label of the questions - or the note - Questions hint are not accounted for as they tips for enumerator and not to be read to respondent
#'   * the time needed to read the question modalities - as there's nothing in xlsform that tells whether the enumerator is expected to read loudly the potential answers in case of closed question, the function has a parameter to 
#'  * the time need to answer the question - here we are accounting for 3 distinct situations, each of them with a different potential duration: - close questions - open questions and open questions set up under skip logic so typically - the "if other, specify" - each comes with distinct response time 
#'  * the time needed when we have a "repeat" block - typically questions repeated for a family roster - 

#'
#' @param xlsformpath path to the file with xlsform
#' @param label_language Language to be used in case you have more than one. If not specified, the 'default_language' in the 'settings' worksheet is used. If that is not specified and more than one language is in the XlsForm, the language that comes first within column order will be used.
#' 
#' @param wpm  word per minute - an average 180 word per minute (per default) required to read loudly the text
#' @param maxmodalities if more than 7 potential answers for a select question (per default)- then we assume that those modalities will not be read by the enumerator - but rather selected based on an open answer - and not be accounted for the modalities duration estimation
#' @param resptimeclose  an average 4 seconds (per default) for respondent to reply for closed questions
#' @param resptimecondopen an average of  7 seconds (per default) to reply to conditional text question (accounting for question type of "other, please specify"). 
#' @param resptimeopen an average of  10 seconds (per default) to reply to open text question. 
#' @param avrgrepeat In case of repeat questions, an average 3 repeat (per default) is accounted for. 
#' 
#' 
#' @return a summary review in a visual format as a gpplot2 chart
#' @export
#' 
#' 
interview_duration <- function(xlsformpath,  
                               label_language = NULL,
                               wpm  = 180, 
                               maxmodalities = 7 , 
                               resptimeclose  = 4,
                               resptimecondopen = 7,
                               resptimeopen = 10,
                               avrgrepeat = 3) {
  require(ggplot2)
  
  # xlsformpath <- "inst/RMS_CAPI_v2_en_es_fr.xlsx"
  survey <- readxl::read_excel(xlsformpath, sheet = "survey")
  
  choices <- readxl::read_excel(xlsformpath, sheet = "choices") 
  
  settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
  
  ## Check if a default language is set up in the settings - and add the correct separator
  # for test settings$default_language <- NULL
  label_language <- ifelse( is.null(label_language),
                                      ifelse( is.null(settings$default_language), 
                                             label_language, 
                                             paste0("::",settings$default_language)),
                                     paste0("::",label_language))
  #label_language 
  
  modalities <- choices |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(labelmod = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language))  ,
                    namemod = name) |>
      ## Estimate how long is need to read the modalities
      dplyr::mutate( labelmod_word = stringr::str_count(labelmod , "\\S+") ) |>
      dplyr::mutate( labelmod_duration = labelmod_word / (wpm/60) ) |>
      ## Calculate number modalities per list_name - if more than 8 - then we assume that
      ## those modalities will not be read by the enumerator and not be accounted for the interview duration estimation
      dplyr::group_by(list_name) |>
      dplyr::summarise( count = dplyr::n(),
                        num_word = sum(labelmod_word),
                        readtime = sum(labelmod_duration) )  
    

  
  
  variables <-  survey |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)),
                    hint =  ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("hint")), paste0("hint",label_language)) ,
                    constraint_message =  dplyr::first(tidyselect::starts_with("constraint_message"))
                   # constraint_message = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("constraint_message")), paste0("constraint_message",label_language))
                    ) |>
      # Take if it's only a label question used fo formatting.. 
      #dplyr::filter( appearance !=  "label") |>
      dplyr::filter( ! (is.na(label))) |>
    
      # Clean the begin and end in case the _ would be missing...
      dplyr::mutate(type = dplyr::recode(type, 
                                          "begin group" = "begin_group" ,
                                          "end group"   ="end_group",
                                         "begin repeat" = "begin_repeat" ,
                                         "end repeat"   ="end_repeat")) |>
      ## separate the type
      tidyr::separate(type, 
                          into = c("type", "list_name"), 
                          sep = " ",
                          fill = "right") |>
    
        # capturing repeat
        dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                      function (repeatvar, type, name) {
                                                        if (type  == "begin_repeat")  c(repeatvar, name)
                                                        else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                        else repeatvar
                                                      }, .init = character()) |> utils::tail(-1),
                      ##Apply a function to each element of a list 
                      repeatvar = purrr::map_chr(repeatvar,
                                                 stringr::str_c, 
                                                 collapse = ".") ,
                      name = dplyr::case_when(repeatvar == "" ~ name,
                                              type == "begin_repeat"~ repeatvar,
                                              TRUE ~ stringr::str_c(repeatvar, name, sep = ".")))  |>
    
    
    ## Remove "silent" question type --
    dplyr::filter( ! (type %in% c("calculate", "end_repeat", "end_group", "start","end", "simserial", "deviceid", "phonenumber", "geopoint" ))    ) |>   
    
    ## Reclassify question type for the summary
    dplyr::mutate(type2 = dplyr::recode(type, "begin_group"="Section",
                                               "begin_repeat"="Section",
                                               "date"="date",
                                               "integer"="number",
                                               "numeric"="number",
                                               "note"= "note", 
                                               "acknowledge"="select", 
                                               "select_multiple"="select",
                                               "select_one"="select",
                                               "select_one_from_file"="select",
                                               "text"= "text") ) |>
    
    ## Apply duration simulation of 4 types
    
    ## Time to read the question label
    dplyr::mutate( label_duration = ifelse( type %in% c("note", "text", "integer", "numeric", "date","select_multiple", "select_one", "select_one_from_file"), 
                                               stringr::str_count(label , "\\S+") / (wpm/60), 
                                               0    )   ) |>
    ## Time to read the potential answer for select questions
    dplyr::left_join(modalities, by = c("list_name")) |>
    dplyr::mutate( modality_duration = ifelse( type %in% c("select_multiple", "select_one") & count <= maxmodalities , 
                                               readtime, 
                                               0    )   ) |>    
    
    ## Time for respondent to reply
    dplyr::mutate( response_duration = dplyr::case_when(type %in% c( "integer",  "numeric", "date","select_multiple", "select_one", "select_one_from_file") ~ resptimeclose,
                                                ( type %in% c( "text") & is.na(constraint))  ~ resptimecondopen,
                                                ( type %in% c( "text") & !(is.na(constraint)))  ~ resptimeopen)   ) |>
    
    ## Time to loop around repeat questions
    dplyr::mutate_at(vars(label_duration, modality_duration, response_duration), ~ tidyr::replace_na(., 0))  |>
    dplyr::mutate( repeat_duration = ifelse( !(repeatvar == ""), 
                                              (label_duration + modality_duration + response_duration) * (avrgrepeat -1) , 
                                               0    )   )  |>
    # Full duration
    dplyr::mutate( question_duration = label_duration+ modality_duration+ response_duration+repeat_duration ) |>
    
    # Cumulative duration
    dplyr::mutate( question_duration_sum = cumsum(question_duration) / 60  ) |>
    
    ## Add a sequence
    dplyr::mutate( order = dplyr::row_number() ) |> 
    dplyr::mutate( seq= paste0(order,"_", type) ) |>
    dplyr::mutate( is_repeated = ifelse(repeatvar =="","once", "repeated")) |>
    dplyr::mutate( is_note = ifelse(type =="note", "yes","no")) |>
    dplyr::mutate( is_question = ifelse(type %in% c("text", "integer", "numeric", "date","select_multiple", "select_one", "select_one_from_file"), "yes","no"))
  
  #  dplyr::mutate( seq= as.factor(seq, forcats::fct_reorder(seq, order)   ) )
  
  ## order the questions
  variables$seq= factor(variables$seq, forcats::fct_reorder(variables$seq, -variables$order) )
  
  ## View summary calculation to check
  # View(variables |> dplyr::select(type, name, label,  is_question, is_note, is_repeated, label_duration ,count, modality_duration, response_duration, repeat_duration, question_duration , question_duration_sum ))
  
  ## Key metrics for the chart title
  totaldur <- round(sum(variables$question_duration)/60,0) 
  totalnote <- variables |> 
                dplyr::group_by( is_note ) |> 
                dplyr::summarise(count = dplyr::n()) |> 
                dplyr::filter( is_note =="yes") |> 
                dplyr::pull()

  totalquestion <- variables |> 
                   dplyr::group_by(is_question) |> 
                   dplyr::summarise(count = dplyr::n()) |> 
                   dplyr::filter( is_question =="yes") |> 
                   dplyr::pull()

  totalrepeatedquestion <- variables |> 
                           dplyr::group_by(is_question, is_repeated) |> 
                           dplyr::summarise(count = dplyr::n()) |> 
                           dplyr::filter( is_question =="yes" & is_repeated == "repeated") |> 
                           dplyr::pull()
  
  #Scaling factor for the second axis
  sf <- max(variables$question_duration_sum)
  
  ## Building a visual summary of the interview duration  
  p <-  ggplot(variables) +
          geom_bar(mapping = aes(x = seq, 
                                 y = question_duration, 
                                 fill = type2),
                   stat = "identity", 
                   position = "identity") +
          geom_line(mapping = aes(x = seq, 
                                  y = question_duration_sum, 
                                  color = is_repeated,
                                  group = 1),
                    #colour = "red", 
                    size = 3 ) + 
          scale_y_continuous(
               name = "Question duration (bar in sec)", 
               sec.axis = sec_axis(~ .  *sf , 
                                   name = "Interview Duration (line in min)")) +
         # coord_flip() + 
          labs(title = stringr::str_wrap(paste0("Estimated interview duration is around ", totaldur," minutes for a total of ",
                              totalnote,                               " notes and ",
                              totalquestion, 
                              " questions, among which ",
                              totalrepeatedquestion,
                              " are repeated" ), 80),
               
               subtitle = stringr::str_wrap(paste0("Assumptions: ",
                    wpm, " words per minute, an average of ",
                    resptimeclose, " seconds for respondent to reply to closed questions, ",
                    resptimecondopen , " seconds to conditional text question, ",
                    resptimeopen, " seconds to open text question. An average ", 
                    avrgrepeat, " repeat records (if included) and a maximum of ", 
                    maxmodalities, " potential answers for closed questions to read loudly by the enumerator."),
                                 100), 
               x = "", y = "", caption = "Built with XlsFormPrettyPrint package") +
          theme_minimal( base_size = 8) +
          geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
          theme( panel.grid.major.x  = element_blank(),
                 panel.grid.major.y  = element_line(color = "#cbcbcb"),
                 panel.grid.minor = element_blank()   ,
                 legend.position = "bottom",legend.title=element_blank(),
                 axis.text.x = element_text(angle = 90)) +
          theme(plot.title.position = "plot")
          
     print(p)
    
}
 

```

```{r examples-interview_duration, fig.width=9, }
## Generate the summary chart
interview_duration( xlsformpath = system.file("demo.xlsx", package = "XlsFormPrettyPrint"), label_language = NULL )


```

```{r tests-interview_duration}
# test_that("skeleton works", {
# 
# })
```



# create_flextable

```{r function-create_flextable}
#' @title Generate a flextable from the pretty printed version of the xlsform
#' 
#' @description Note that better legibility, it is advised to put the select question with many possible answers - typically something like "what is your country of origin?" -  as 'select_from_file'
#'
#' @param xlsformpath path to the file with xlsform
#' 
#' @param label_language Language to be used in case you have more than one. If not specified, the 'default_language' in the 'settings' worksheet is used. If that is not specified and more than one language is in the XlsForm, the language that comes first within column order will be used.
#' 
#' @return a flextable ready to be printed in an Rmd template for word - using officedown.
#' @export
#'
create_flextable <- function(xlsformpath, label_language ) {
  
    variables <- tabulate_form(xlsformpath, label_language )
      # create a flex table
    ft <- flextable::flextable(variables) 
    
    #   ## Add theme
    ft <- flextable::colformat_double(ft, big.mark = "'", decimal.mark = ",", digits = 1)
      
    ft <- flextable::set_table_properties(ft, layout = "autofit")
      
     ft <- flextable::border_remove(ft)
      
     std_border <- officer::fp_border(width = 1, color = "grey")
      
     ft <- flextable::border_outer(ft , 
                        part="all", 
                        border = std_border )
     ft <- flextable::border_inner_h(ft, 
                          part="all", 
                          border = std_border)
     ft <- flextable::border_inner_v(ft, 
                          part="all", 
                          border = std_border)
    
    #  need to merge cells based on rules
    ##  vertical merging of similar values to address merging with modalities when it's the case
    ft <- flextable::merge_v(ft, j = c("name_type", "label_hint",  "instruct" ))
    
    
    ## horizontal merging in case of beging_group - end_group - begin_repeat, end_repeat
    
    # ft <- merge_at(ft, 
    #                  j = 2:4, 
    #                  i = 3 ,
    #                  part = "body")
    
    ## identify the line with group
    lines_begin_group <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "begin_group" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_begin_group) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 2:4, 
                     part = "body")
      ft <- flextable::bg(ft, 
               bg = "#ffa630",
               i =  lines,
               part = "body")
      
     # ft <- bold(ft, i =  lines, part = "body")
    }
    
    lines_end_group <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "end_group") ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_end_group) {
      ft <- flextable::merge_at(ft,
                     i = lines,
                     j = 2:4,
                     part = "body")
      ft <- flextable::bg(ft, 
               bg = "#ffa630",
               i =  lines,
               part = "body")
    }
    
    
    # with repeat
    lines_begin_repeat <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "begin_repeat") ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_begin_repeat) {
      ft <- flextable::merge_at(ft,
                     i = lines,
                     j = 2:4,
                     part = "body")
      ft <- flextable::bg(ft, 
               bg = "#00a7e1",
               i =  lines,
               part = "body")
      
      #ft <- bold(ft, i =  lines, part = "body")
    }
    
    lines_end_repeat <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "end_repeat") ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_end_repeat) {
      ft <- flextable::merge_at(ft,
                     i = lines,
                     j = 2:4,
                     part = "body")
      ft <- flextable::bg(ft, 
               bg = "#00a7e1",
               i =  lines,
               part = "body")
    }
    
    ## with note
    lines_note <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "note" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_note) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 2:4, 
                     part = "body")
      ft <- flextable::bg(ft, 
               bg = "#ebebeb",
               i =  lines,
               part = "body")
    }
    
    ## with date
    lines_date <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "date" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_date) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 3:4, 
                     part = "body")
    }
    
    ## with integer
    lines_integer <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "integer" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_integer) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 3:4, 
                     part = "body")
    }
    
    ## with numeric
    lines_numeric <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "numeric" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_numeric) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 3:4, 
                     part = "body")
    }
    
    ## with numeric
    lines_text <- variables |>
      dplyr::mutate( rows = dplyr::row_number()) |>
      dplyr::filter( stringr::str_detect(name_type, "text" ) ) |>
      dplyr::select(rows) |>
      dplyr::pull()
    
    for (lines in lines_text) {
      ft <- flextable::merge_at(ft, 
                     i = lines, 
                     j = 3:4, 
                     part = "body")
    }
    
    ## Adding top headers
    # ft <- add_header_row(ft,  colwidths = c(2, 2, 1), 
    #                      values = c("Questions", "Responses", "Check") )
    
    
    # et voila! 
    
      return(ft)
}
 

```

```{r examples-create_flextable}
create_flextable(xlsformpath = system.file("demo.xlsx", package = "XlsFormPrettyPrint"), label_language = NULL )
```

```{r tests-create_flextable}
# test_that("skeleton works", {
# 
# })
```

# xlsform_compare

```{r function-xlsform_compare}
#' @title Generate a consolidated xlsform from a list of xlsform in order to quickly flag differences
#' 
#' @description Note that comparison is done for a selected language
#'
#' @param listfile list of  path to multiple xlsform files - ll assumed to be in the same folder. The first one will be used as the master to compare the other to
#' 
#' @param folder where all the files are located
#' 
#' @param label_language Language to be used in case you have more than one. If not specified, the 'default_language' in the 'settings' worksheet is used. If that is not specified and more than one language is in the XlsForm, the language that comes first within column order will be used.
#' 
#' @param fileout  if specified defined the name of the file to save the xlsform_compare output
#' 
#' @return a file .
#' @export
#'
xlsform_compare <- function( listfile,
                             folder,
                             label_language,
                             fileout = NULL) {
  # library(XlsFormPrettyPrint)
  formthis <- listfile[1]
  xlsformpath = here::here(folder, formthis)

  settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
  #form_instance <- as.character(settings$form_title)

  ## Check if a default language is set up in the settings - and add the correct separator
  # for test settings$default_language <- NULL
  label_language <- ifelse( is.null(label_language),
                            ifelse( is.null(settings$default_language),
                                    label_language,
                                    paste0("::",settings$default_language)),
                            paste0("::",label_language))


  #### Choices master to... ######
  choicesmaster <- readxl::read_excel(xlsformpath, sheet = "choices") |>
    # dplyr::mutate(form_instance = form_instance)|>
    dplyr::mutate(form_file = stringr::str_remove(formthis, ".xlsx")) |>
    #  Rename and use what ever label set is coming first
    dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)) ,
                  name = name) |>
    dplyr::filter(!(is.na(list_name))) |>
    dplyr::select(list_name ,name, label, form_file)
  
  
   
  survey <-  readxl::read_excel(xlsformpath, sheet = "survey")
    if ("required" %in% colnames(survey)) {   } else {    survey$required <- ""   }
    if ("relevant" %in% colnames(survey)) {   } else {    survey$relevant <- ""   }
    if ("constraint" %in% colnames(survey)) {   } else {    survey$constraint <- ""   }

  #### Variables master to... ######
  variablesmaster <-  survey |>
    ## Rename and use what ever label set is coming first
    dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)),
                  hint =  ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("hint")), paste0("hint",label_language))  ) |>

    #dplyr::mutate(form_instance = form_instance)|>
    dplyr::mutate(form_file = stringr::str_remove(formthis, ".xlsx")) |>

    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type,
                                       "begin group" = "begin_group" ,
                                       "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>

    ## separate the type
    tidyr::separate(type,
                    into = c("type", "list_name"),
                    sep = " ",
                    fill = "right")   |>

    # dplyr::mutate(name_type = glue::glue('{name} \n *(type: {type})')) |>
    # dplyr::mutate(label_hint = glue::glue('{label} \n *(hint: {hint})')) |>
    dplyr::mutate(name_type = paste0(name, "\n *(type: ",type, ")")) |>
    dplyr::mutate(label_hint = paste0(
      ifelse(is.na(label), "no label", label),
      ifelse(is.na(hint), "",
             paste0("\n *(hint: ", hint, ")")
      ) )) |>

    ## Need to add more cleaning in case...
    dplyr::filter(!(is.na(type))) |>
    dplyr::select(type, list_name, name, label, hint, required, relevant, constraint, 
                  form_file)

  ## initiate comparison
  choicescompare <- choicesmaster
  variablescompare <- variablesmaster

  #### Now looping around the list of file to compare the master to... ######
  for ( i in 2:length(listfile ))  {
    # i <- 2
    formthis <- listfile[i]
    cat(paste0(formthis, "\n\n"))
    xlsformpath = here::here(folder, formthis)
    #variables <- tabulate_form(xlsformpath, label_language )
    settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
    #form_instance <- as.character(settings$form_title)
    choices <- readxl::read_excel(xlsformpath, sheet = "choices") |>
      # dplyr::mutate(form_instance = form_instance)|>
      dplyr::mutate(form_file = stringr::str_remove(formthis, ".xlsx")) |>
      #  Rename and use what ever label set is coming first
      dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)) ,
                    name = name)  |>
      dplyr::filter(!(is.na(list_name))) |>
      dplyr::select(list_name ,name, label, form_file)

    ### Add & diff
    choicescompare <- dplyr::full_join(choicescompare, choices, by = c("list_name", "name"), suffix=c("",".diff") )|>
      dplyr::filter(!(is.na(list_name))) |>
      ##  clean the diff type comparison
      dplyr::mutate ( label.diff = dplyr::case_when(is.na(label) ~ label.diff,
                                                    is.na(label.diff) ~ "<<missing>>",
                                                    label.diff == label ~  NA_character_,
                                                    label.diff != label ~  label.diff )
                      #label.diff = dplyr::if_else(is.na(label),label.diff , dplyr::if_else( label.diff == label, NA_character_, label.diff ))
      )
    ## Rename diff based on type and file origin
    eval(parse(text=paste0("choicescompare$label.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- choicescompare$label.diff ") ))
    choicescompare$label.diff <- NULL
    choicescompare$form_file <- NULL
    choicescompare$form_file.diff <- NULL

    
    
    ## Now variable ####
      survey <-  readxl::read_excel(xlsformpath, sheet = "survey")
    if ("required" %in% colnames(survey)) {   } else {    survey$required <- ""   }
    if ("relevant" %in% colnames(survey)) {   } else {    survey$relevant <- ""   }
    if ("constraint" %in% colnames(survey)) {   } else {    survey$constraint <- ""   }
    
    variables <-  survey |>
      ## Rename and use what ever label set is coming first
      dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)),
                    hint =  ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("hint")), paste0("hint",label_language))   ) |>
      #dplyr::mutate(form_instance = form_instance)|>
      dplyr::mutate(form_file = stringr::str_remove(formthis, ".xlsx")) |>
      # Clean the begin and end in case the _ would be missing...
      dplyr::mutate(type = dplyr::recode(type,
                                         "begin group" = "begin_group" ,
                                         "end group"   ="end_group",
                                         "begin repeat" = "begin_repeat" ,
                                         "end repeat"   ="end_repeat")) |>
      ## separate the type
      tidyr::separate(type,
                      into = c("type", "list_name"),
                      sep = " ",
                      fill = "right") |>
    ## Need to add more cleaning in case...
    dplyr::filter(!(is.na(type))) |>
    dplyr::select(type, list_name, name, label, hint, required, relevant, constraint,  form_file) #|>
    #dplyr::distinct()

    ### Add & diff
    variablescompare <- dplyr::full_join(variablescompare, variables, by = c( "name"), suffix=c("",".diff") ) |>
      dplyr::filter(!(is.na(name))) |>
      ##  clean the diff type comparison

      dplyr::mutate (type.diff = dplyr::case_when(is.na(type) ~ type.diff,
                                                  is.na(type.diff) ~ "<<missing>>",
                                                  type.diff == type ~  NA_character_ ,
                                                  type.diff != type ~ type.diff ) ,
                     list_name.diff = dplyr::case_when(is.na(list_name) ~ list_name.diff,
                                                       is.na(list_name.diff) ~ "<<missing>>",
                                                       list_name.diff == list_name ~ NA_character_,
                                                       list_name.diff != list_name ~  list_name.diff ),
                     label.diff = dplyr::case_when(is.na(label) ~ label.diff,
                                                   is.na(label.diff) ~ "<<missing>>",
                                                   label.diff == label ~  NA_character_,
                                                   label.diff != label ~  label.diff ),
                     hint.diff = dplyr::case_when(is.na(hint) ~ hint.diff,
                                                  is.na(hint.diff) ~ "<<missing>>",
                                                  hint.diff == hint ~  NA_character_,
                                                  hint.diff != hint ~  hint.diff ),
                     required.diff = dplyr::case_when(is.na(required) ~ required.diff,
                                                      is.na(required.diff) ~ "<<missing>>",
                                                      required.diff == required ~  NA_character_,
                                                      required.diff != required ~  required.diff ),
                     constraint.diff = dplyr::case_when(is.na(constraint) ~ constraint.diff,
                                                        is.na(constraint.diff) ~ "<<missing>>",
                                                        constraint.diff == constraint ~ NA_character_,
                                                        constraint.diff != constraint ~  constraint.diff ),
                     relevant.diff = dplyr::case_when(is.na(relevant) ~ relevant.diff,
                                                      is.na(relevant.diff) ~ "<<missing>>",
                                                      relevant.diff == relevant ~  NA_character_,
                                                      relevant.diff != type ~  relevant.diff ))





    # dplyr::mutate (type.diff = dplyr::if_else(is.na(type),type.diff , dplyr::if_else(type.diff == type, NA_character_, type.diff )),
    #                list_name.diff = dplyr::if_else(is.na(list_name),list_name.diff , dplyr::if_else( list_name.diff == list_name, NA_character_, list_name.diff )),
    #                label.diff = dplyr::if_else(is.na(label),label.diff , dplyr::if_else( label.diff == label, NA_character_, label.diff )),
    #                hint.diff = dplyr::if_else(is.na(hint),hint.diff , dplyr::if_else( hint.diff == hint, NA_character_, hint.diff )),
    #                required.diff = dplyr::if_else(is.na(required),required.diff , dplyr::if_else( required.diff == required, NA_character_, required.diff )),
    #                constraint.diff = dplyr::if_else(is.na(constraint),constraint.diff , dplyr::if_else( constraint.diff == constraint, NA_character_, constraint.diff )),
    #                relevant.diff = dplyr::if_else(is.na(relevant),relevant.diff , dplyr::if_else( relevant.diff == relevant, NA_character_, relevant.diff )))
    ## Rename diff based on type and file origin
    eval(parse(text=paste0("variablescompare$type.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$type.diff ") ))
    eval(parse(text=paste0("variablescompare$list_name.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$list_name.diff ") ))
    eval(parse(text=paste0("variablescompare$label.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$label.diff ") ))
    eval(parse(text=paste0("variablescompare$hint.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$hint.diff ") ))
    eval(parse(text=paste0("variablescompare$required.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$required.diff ") ))
    eval(parse(text=paste0("variablescompare$constraint.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$constraint.diff ") ))
    eval(parse(text=paste0("variablescompare$relevant.ifdiff.", stringr::str_remove(formthis, ".xlsx"), " <- variablescompare$relevant.diff ") ))
    #and remove previous column
    variablescompare$type.diff <- NULL
    variablescompare$list_name.diff <- NULL
    variablescompare$label.diff <- NULL
    variablescompare$hint.diff <- NULL
    variablescompare$required.diff <- NULL
    variablescompare$relevant.diff <- NULL
    variablescompare$constraint.diff <- NULL
    variablescompare$form_file <- NULL
    variablescompare$form_file.diff <- NULL

  }


  variablescompare <- variablescompare |>
    dplyr::select( name,
                   type,
                   starts_with("type.ifdiff."),
                   list_name,
                   starts_with("list_name.ifdiff."),
                   label,
                   starts_with("label.ifdiff."),
                   hint,
                   starts_with("hint.ifdiff."),
                   required,
                   starts_with("required.ifdiff."),
                   relevant,
                   starts_with("constraint.ifdiff."),
                   constraint,
                   starts_with("relevant.ifdiff")
    )

  choicescompare <- choicescompare |>
    dplyr::select( name,
                   list_name,
                   label,
                   starts_with("label.ifdiff.")  )

  # names(variablescompare)
  # names(choicescompare)

  ## Save in Excel if fileout is not null
  if ( !(is.null(fileout))) {
        ## Create a blank workbook
        wb <- openxlsx::createWorkbook()

        # Excel Styling Elements
        # To add filters for sheet, we have to set the range for addAutoFilter() function
        # EX: addAutoFilter(sheet1, "A1:P1") --> add a filter on the 1rd row, columns A:P
        # dfref dataframe allows to find 'P' based on number of columns in the sheet, if number of columns equal to 6 then the range will be A1:dfref[6,] -- A1:F1
        dfref <- data.frame(
          key = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256),
          val = c('A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1', 'J1', 'K1', 'L1', 'M1', 'N1', 'O1', 'P1', 'Q1', 'R1', 'S1', 'T1', 'U1', 'V1', 'W1', 'X1', 'Y1', 'Z1', 'AA1', 'AB1', 'AC1', 'AD1', 'AE1', 'AF1', 'AG1', 'AH1', 'AI1', 'AJ1', 'AK1', 'AL1', 'AM1', 'AN1', 'AO1', 'AP1', 'AQ1', 'AR1', 'AS1', 'AT1', 'AU1', 'AV1', 'AW1', 'AX1', 'AY1', 'AZ1', 'BA1', 'BB1', 'BC1', 'BD1', 'BE1', 'BF1', 'BG1', 'BH1', 'BI1', 'BJ1', 'BK1', 'BL1', 'BM1', 'BN1', 'BO1', 'BP1', 'BQ1', 'BR1', 'BS1', 'BT1', 'BU1', 'BV1', 'BW1', 'BX1', 'BY1', 'BZ1', 'CA1', 'CB1', 'CC1', 'CD1', 'CE1', 'CF1', 'CG1', 'CH1', 'CI1', 'CJ1', 'CK1', 'CL1', 'CM1', 'CN1', 'CO1', 'CP1', 'CQ1', 'CR1', 'CS1', 'CT1', 'CU1', 'CV1', 'CW1', 'CX1', 'CY1', 'CZ1', 'DA1', 'DB1', 'DC1', 'DD1', 'DE1', 'DF1', 'DG1', 'DH1', 'DI1', 'DJ1', 'DK1', 'DL1', 'DM1', 'DN1', 'DO1', 'DP1', 'DQ1', 'DR1', 'DS1', 'DT1', 'DU1', 'DV1', 'DW1', 'DX1', 'DY1', 'DZ1', 'EA1', 'EB1', 'EC1', 'ED1', 'EE1', 'EF1', 'EG1', 'EH1', 'EI1', 'EJ1', 'EK1', 'EL1', 'EM1', 'EN1', 'EO1', 'EP1', 'EQ1', 'ER1', 'ES1', 'ET1', 'EU1', 'EV1', 'EW1', 'EX1', 'EY1', 'EZ1', 'FA1', 'FB1', 'FC1', 'FD1', 'FE1', 'FF1', 'FG1', 'FH1', 'FI1', 'FJ1', 'FK1', 'FL1', 'FM1', 'FN1', 'FO1', 'FP1', 'FQ1', 'FR1', 'FS1', 'FT1', 'FU1', 'FV1', 'FW1', 'FX1', 'FY1', 'FZ1', 'GA1', 'GB1', 'GC1', 'GD1', 'GE1', 'GF1', 'GG1', 'GH1', 'GI1', 'GJ1', 'GK1', 'GL1', 'GM1', 'GN1', 'GO1', 'GP1', 'GQ1', 'GR1', 'GS1', 'GT1', 'GU1', 'GV1', 'GW1', 'GX1', 'GY1', 'GZ1', 'HA1', 'HB1', 'HC1', 'HD1', 'HE1', 'HF1', 'HG1', 'HH1', 'HI1', 'HJ1', 'HK1', 'HL1', 'HM1', 'HN1', 'HO1', 'HP1', 'HQ1', 'HR1', 'HS1', 'HT1', 'HU1', 'HV1', 'HW1', 'HX1', 'HY1', 'HZ1', 'IA1', 'IB1', 'IC1', 'ID1', 'IE1', 'IF1', 'IG1', 'IH1', 'II1', 'IJ1', 'IK1', 'IL1', 'IM1', 'IN1', 'IO1', 'IP1', 'IQ1', 'IR1', 'IS1', 'IT1', 'IU1', 'IV1')
        )

        #For better legibility create specific styles for rows that defines header
        headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                           border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
        #For better legibility create specific styles for rows that defines groups
        cs1 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "black", fgFill = "orange",
                                      border = "TopBottom", borderColour = "orange", borderStyle = "thin")
        #For better legibility create specific styles for rows that defines repeat
        cs2 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fgFill = "skyblue",
                                      border = "TopBottom", borderColour = "skyblue", borderStyle = "thin")
        sheetname <- "variablescompare"
        openxlsx::addWorksheet(wb, sheetname)
        openxlsx::writeData(wb, sheetname, variablescompare, withFilter = TRUE)
        openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(variablescompare), widths = "auto")
        all.cols <- 1:ncol(variablescompare)
        hdr.rows <- 1
        group.rows <- which(stringr::str_detect(variablescompare$type, "group"))+1
        repeat.rows <- which(stringr::str_detect(variablescompare$type, "repeat"))+1
        openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, all.cols, gridExpand = TRUE)
        openxlsx::addStyle(wb, sheetname, cs1, group.rows, all.cols, gridExpand = TRUE)
        openxlsx::addStyle(wb, sheetname, cs2, repeat.rows, all.cols, gridExpand = TRUE)

        sheetname <- "choicescompare"
        openxlsx::addWorksheet(wb, sheetname)
        openxlsx::writeData(wb, sheetname, choicescompare, withFilter = TRUE)
        openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(choicescompare), widths = "auto")

        xlsformpathout <- here::here(folder,fileout)
       # wb
        if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
        cat( paste0(xlsformpathout,"\n"))
        openxlsx::saveWorkbook(wb, file = xlsformpathout, overwrite = FALSE, returnValue = FALSE)
  }

  diffinform <-list(variablescompare,choicescompare )
  return(diffinform)

}
 

```

```{r examples-xlsform_compare}

check <- xlsform_compare(listfile = c( "demo.xlsx","demo_adapt1.xlsx","demo_adapt2.xlsx"),  
                         folder = stringr::str_sub(system.file("", package = "XlsFormPrettyPrint"), end = -1) ,                    
                         label_language = NULL,
                         fileout = NULL)

# variablescompare,
knitr::kable(utils::head(as.data.frame(check[1]), 10))
# choicescompare
knitr::kable(utils::head(as.data.frame(check[2]), 10, 10))

```

```{r tests-xlsform_compare}
# test_that("skeleton works", {
# 
# })
```




```{r development-inflate, eval=FALSE}

pkgdown::build_site()

# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/dev_doc_fusen.Rmd", vignette_name = "XlsFormPrettyPrint Functions")
```

