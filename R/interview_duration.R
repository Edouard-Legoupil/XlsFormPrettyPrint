# WARNING - Generated by {fusen} from /dev/dev_doc_fusen.Rmd: do not edit by hand

#' @title Prepare a summary estimation of the interview duration. 
#' 
#' @description When designing a questionnaire, it is key to keep the interview duration under control. Typically less than 20 minutes for a phone interview and less than 40 minutes for a face to face interview. 
#' 
#' The function is designed to provide a rough estimate (aka a guesstimate...) of the interview duration in order to assess this element of questionnaire design quality. If the questionnaire takes too long, then one needs to trim it or split it into multiple ones...
#' 
#' The estimations provided in that function are based on a series of assumptions and accounts for the following elements:
#'   * the time needed to read the label of the questions - or the note - Questions hint are not accounted for as they tips for enumerator and not to be read to respondent
#'   * the time needed to read the question modalities - as there's nothing in xlsform that tells whether the enumerator is expected to read loudly the potential answers in case of closed question, the function has a parameter to 
#'  * the time need to answer the question - here we are accounting for 3 distinct situations, each of them with a different potential duration: - close questions - open questions and open questions set up under skip logic so typically - the "if other, specify" - each comes with distinct response time 
#'  * the time needed when we have a "repeat" block - typically questions repeated for a family roster - 

#'
#' @param xlsformpath path to the file with xlsform
#' @param label_language Language to be used in case you have more than one. If not specified, the 'default_language' in the 'settings' worksheet is used. If that is not specified and more than one language is in the XlsForm, the language that comes first within column order will be used.
#' 
#' @param wpm  word per minute - an average 180 word per minute (per default) required to read loudly the text
#' @param maxmodalities if more than 7 potential answers for a select question (per default)- then we assume that those modalities will not be read by the enumerator - but rather selected based on an open answer - and not be accounted for the modalities duration estimation
#' @param resptimeclose  an average 4 seconds (per default) for respondent to reply for closed questions
#' @param resptimecondopen an average of  7 seconds (per default) to reply to conditional text question (accounting for question type of "other, please specify"). 
#' @param resptimeopen an average of  10 seconds (per default) to reply to open text question. 
#' @param avrgrepeat In case of repeat questions, an average 3 repeat (per default) is accounted for. 
#' 
#' 
#' @return a summary review in a visual format as a gpplot2 chart
#' @export
#' 
#' 
#' @examples
#' ## Generate the summary chart
#' interview_duration( xlsformpath = system.file("demo.xlsx", package = "XlsFormPrettyPrint"), label_language = NULL )
#' 
#' 
interview_duration <- function(xlsformpath,  
                               label_language = NULL,
                               wpm  = 180, 
                               maxmodalities = 7 , 
                               resptimeclose  = 4,
                               resptimecondopen = 7,
                               resptimeopen = 10,
                               avrgrepeat = 3) {
  require(ggplot2)
  
  # xlsformpath <- "inst/RMS_CAPI_v2_en_es_fr.xlsx"
  survey <- readxl::read_excel(xlsformpath, sheet = "survey")
  
  choices <- readxl::read_excel(xlsformpath, sheet = "choices") 
  
  settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
  
  ## Check if a default language is set up in the settings - and add the correct separator
  # for test settings$default_language <- NULL
  label_language <- ifelse( is.null(label_language),
                                      ifelse( is.null(settings$default_language), 
                                             label_language, 
                                             paste0("::",settings$default_language)),
                                     paste0("::",label_language))
  #label_language 
  
  modalities <- choices |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(labelmod = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language))  ,
                    namemod = name) |>
      ## Estimate how long is need to read the modalities
      dplyr::mutate( labelmod_word = stringr::str_count(labelmod , "\\S+") ) |>
      dplyr::mutate( labelmod_duration = labelmod_word / (wpm/60) ) |>
      ## Calculate number modalities per list_name - if more than 8 - then we assume that
      ## those modalities will not be read by the enumerator and not be accounted for the interview duration estimation
      dplyr::group_by(list_name) |>
      dplyr::summarise( count = dplyr::n(),
                        num_word = sum(labelmod_word),
                        readtime = sum(labelmod_duration) )  
    

  
  
  variables <-  survey |>
      ## Rename and use what ever label set is coming first 
      dplyr::rename(label = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("label")), paste0("label",label_language)),
                    hint =  ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("hint")), paste0("hint",label_language)) ,
                    constraint_message =  dplyr::first(tidyselect::starts_with("constraint_message"))
                   # constraint_message = ifelse( is.null(label_language), dplyr::first(tidyselect::starts_with("constraint_message")), paste0("constraint_message",label_language))
                    ) |>
      # Take if it's only a label question used fo formatting.. 
      #dplyr::filter( appearance !=  "label") |>
      dplyr::filter( ! (is.na(label))) |>
    
      # Clean the begin and end in case the _ would be missing...
      dplyr::mutate(type = dplyr::recode(type, 
                                          "begin group" = "begin_group" ,
                                          "end group"   ="end_group",
                                         "begin repeat" = "begin_repeat" ,
                                         "end repeat"   ="end_repeat")) |>
      ## separate the type
      tidyr::separate(type, 
                          into = c("type", "list_name"), 
                          sep = " ",
                          fill = "right") |>
    
        # capturing repeat
        dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                      function (repeatvar, type, name) {
                                                        if (type  == "begin_repeat")  c(repeatvar, name)
                                                        else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                        else repeatvar
                                                      }, .init = character()) |> utils::tail(-1),
                      ##Apply a function to each element of a list 
                      repeatvar = purrr::map_chr(repeatvar,
                                                 stringr::str_c, 
                                                 collapse = ".") ,
                      name = dplyr::case_when(repeatvar == "" ~ name,
                                              type == "begin_repeat"~ repeatvar,
                                              TRUE ~ stringr::str_c(repeatvar, name, sep = ".")))  |>
    
    
    ## Remove "silent" question type --
    dplyr::filter( ! (type %in% c("calculate", "end_repeat", "end_group", "start","end", "simserial", "deviceid", "phonenumber", "geopoint" ))    ) |>   
    
    ## Reclassify question type for the summary
    dplyr::mutate(type2 = dplyr::recode(type, "begin_group"="Section",
                                               "begin_repeat"="Section",
                                               "date"="date",
                                               "integer"="number",
                                               "numeric"="number",
                                               "note"= "note", 
                                               "acknowledge"="select", 
                                               "select_multiple"="select",
                                               "select_one"="select",
                                               "select_one_from_file"="select",
                                               "text"= "text") ) |>
    
    ## Apply duration simulation of 4 types
    
    ## Time to read the question label
    dplyr::mutate( label_duration = ifelse( type %in% c("note", "text", "integer", "numeric", "date","select_multiple", "select_one", "select_one_from_file"), 
                                               stringr::str_count(label , "\\S+") / (wpm/60), 
                                               0    )   ) |>
    ## Time to read the potential answer for select questions
    dplyr::left_join(modalities, by = c("list_name")) |>
    dplyr::mutate( modality_duration = ifelse( type %in% c("select_multiple", "select_one") & count <= maxmodalities , 
                                               readtime, 
                                               0    )   ) |>    
    
    ## Time for respondent to reply
    dplyr::mutate( response_duration = dplyr::case_when(type %in% c( "integer",  "numeric", "date","select_multiple", "select_one", "select_one_from_file") ~ resptimeclose,
                                                ( type %in% c( "text") & is.na(constraint))  ~ resptimecondopen,
                                                ( type %in% c( "text") & !(is.na(constraint)))  ~ resptimeopen)   ) |>
    
    ## Time to loop around repeat questions
    dplyr::mutate_at(vars(label_duration, modality_duration, response_duration), ~ tidyr::replace_na(., 0))  |>
    dplyr::mutate( repeat_duration = ifelse( !(repeatvar == ""), 
                                              (label_duration + modality_duration + response_duration) * (avrgrepeat -1) , 
                                               0    )   )  |>
    # Full duration
    dplyr::mutate( question_duration = label_duration+ modality_duration+ response_duration+repeat_duration ) |>
    
    # Cumulative duration
    dplyr::mutate( question_duration_sum = cumsum(question_duration) / 60  ) |>
    
    ## Add a sequence
    dplyr::mutate( order = dplyr::row_number() ) |> 
    dplyr::mutate( seq= paste0(order,"_", type) ) |>
    dplyr::mutate( is_repeated = ifelse(repeatvar =="","once", "repeated")) |>
    dplyr::mutate( is_note = ifelse(type =="note", "yes","no")) |>
    dplyr::mutate( is_question = ifelse(type %in% c("text", "integer", "numeric", "date","select_multiple", "select_one", "select_one_from_file"), "yes","no"))
  
  #  dplyr::mutate( seq= as.factor(seq, forcats::fct_reorder(seq, order)   ) )
  
  ## order the questions
  variables$seq= factor(variables$seq, forcats::fct_reorder(variables$seq, -variables$order) )
  
  ## View summary calculation to check
  # View(variables |> dplyr::select(type, name, label,  is_question, is_note, is_repeated, label_duration ,count, modality_duration, response_duration, repeat_duration, question_duration , question_duration_sum ))
  
  ## Key metrics for the chart title
  totaldur <- round(sum(variables$question_duration)/60,0) 
  totalnote <- variables |> 
                dplyr::group_by( is_note ) |> 
                dplyr::summarise(count = dplyr::n()) |> 
                dplyr::filter( is_note =="yes") |> 
                dplyr::pull()

  totalquestion <- variables |> 
                   dplyr::group_by(is_question) |> 
                   dplyr::summarise(count = dplyr::n()) |> 
                   dplyr::filter( is_question =="yes") |> 
                   dplyr::pull()

  totalrepeatedquestion <- variables |> 
                           dplyr::group_by(is_question, is_repeated) |> 
                           dplyr::summarise(count = dplyr::n()) |> 
                           dplyr::filter( is_question =="yes" & is_repeated == "repeated") |> 
                           dplyr::pull()
  
  #Scaling factor for the second axis
  sf <- max(variables$question_duration_sum)
  
  ## Building a visual summary of the interview duration  
  p <-  ggplot(variables) +
          geom_bar(mapping = aes(x = seq, 
                                 y = question_duration, 
                                 fill = type2),
                   stat = "identity", 
                   position = "identity") +
          geom_line(mapping = aes(x = seq, 
                                  y = question_duration_sum, 
                                  color = is_repeated,
                                  group = 1),
                    #colour = "red", 
                    size = 3 ) + 
          scale_y_continuous(
               name = "Question duration (bar in sec)", 
               sec.axis = sec_axis(~ .  *sf , 
                                   name = "Interview Duration (line in min)")) +
         # coord_flip() + 
          labs(title = stringr::str_wrap(paste0("Estimated interview duration is around ", totaldur," minutes for a total of ",
                              totalnote,                               " notes and ",
                              totalquestion, 
                              " questions, among which ",
                              totalrepeatedquestion,
                              " are repeated" ), 90),
               
               subtitle = stringr::str_wrap(paste0("Assumptions: ",
                    wpm, " words per minute, an average of ",
                    resptimeclose, " seconds for respondent to reply to closed questions, ",
                    resptimecondopen , " seconds to conditional text question, ",
                    resptimeopen, " seconds to open text question. An average ", 
                    avrgrepeat, " repeat records (if included) and a maximum of ", 
                    maxmodalities, " potential answers for closed questions to read loudly by the enumerator."),
                                 110), 
               x = "", y = "", caption = "Built with XlsFormPrettyPrint package") +
          theme_minimal( base_size = 16) +
          geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
          theme( panel.grid.major.x  = element_blank(),
                 panel.grid.major.y  = element_line(color = "#cbcbcb"),
                 panel.grid.minor = element_blank()   ,
                 legend.position = "bottom",legend.title=element_blank(),
                 axis.text.x = element_text(angle = 90)) +
          theme(plot.title.position = "plot")
          
     print(p)
    
}
 

